use super::{exec, GitError};
use std::collections::HashMap;
use std::path::Path;
use types::*;

pub fn parse_raw_tokens<'a>(
    tokens: &'a [&'a str],
) -> Result<(Vec<(String, FileEntry)>, &'a [&'a str]), GitError> {
    let mut i = 0;
    let mut ret: Vec<(String, FileEntry)> = Vec::new();
    while i < tokens.len() {
        let token = tokens[i];
        if token.starts_with(":") {
            // RAW OUTPUT
            let status_code = token.split(" ").nth(4).unwrap();
            let status = &status_code[0..1];
            match status {
                "M" | "A" | "D" | "T" | "U" => {
                    i += 1;
                    let path: &str = tokens[i];
                    let file = FileEntry::new(path, status_code, None, None);
                    ret.push((path.to_owned(), file));
                }
                "R" | "C" => {
                    i += 1;
                    let old_path = tokens[i];
                    i += 1;
                    let path = tokens[i];
                    let file = FileEntry::new(path, status_code, Some(&old_path), None);
                    ret.push((path.to_owned(), file));
                }
                _ => {
                    return Err(GitError::UnexpectedOutput {
                        command: String::from("numstat"),
                        text: format!("unknown status code: {}", token),
                    });
                }
            }
        } else {
            // NUMSTAT
            break;
        }
        i += 1;
    }
    Ok((ret, &tokens[i..]))
}

pub fn parse_numstat_tokens(tokens: &[&str]) -> Result<Vec<(String, FileDelta)>, GitError> {
    let mut i = 0;
    let mut ret: Vec<(String, FileDelta)> = Vec::new();
    while i < tokens.len() {
        let token = tokens[i];
        // NUMSTAT
        let values = token.split("\t").collect::<Vec<_>>();
        if values.len() != 3 {
            return Err(GitError::UnexpectedOutput {
                command: String::from("numstat"),
                text: format!("unknown numstat output: {}", token),
            });
        }
        let path = if values[2].len() > 0 {
            values[2]
        } else {
            i += 2;
            tokens[i]
        };
        let delta = match (values[0].parse::<u32>(), values[1].parse::<u32>()) {
            (Ok(insertions), Ok(deletions)) => FileDelta::Text {
                insertions,
                deletions,
            },
            _ => FileDelta::Binary,
        };
        ret.push((path.to_owned(), delta));
        i += 1;
    }
    Ok(ret)
}

/**
 * parse output generated with `--numstat --raw -z`
 *
 *  Raw output format  https://git-scm.com/docs/git-diff#_raw_output_format
 *    in-place edit  :100644 100644 bcd1234 0123456 M<NUL>file0<NUL>
 *    copy-edit      :100644 100644 abcd123 1234567 C68<NUL>file1<NUL>file2<NUL>
 *    rename-edit    :100644 100644 abcd123 1234567 R86<NUL>file1<NUL>file3<NUL>
 *    create         :000000 100644 0000000 1234567 A<NUL>file4<NUL>
 *    delete         :100644 000000 1234567 0000000 D<NUL>file5<NUL>
 *    unmerged       :000000 000000 0000000 0000000 U<NUL>file6<NUL>
 *
 *  Numstat output format
 *    rename/copy    insertions<TAB>deletions<TAB><NUL>old path<NUL>new path<NUL>
 *    others         insertions<TAB>deletions<TAB>path<NUL>
 *
 *    insertions/deletions are inserted/deleted line count, or "-" when it is binary.
 */
pub fn parse_raw_numstat_rows(text: &str) -> Result<Vec<FileEntry>, GitError> {
    let mut ret: Vec<FileEntry> = Vec::new();
    let tokens: Vec<&str> = text.split("\0").filter(|v| v.len() > 0).collect();
    // parse raw rows
    let (files, rest) = parse_raw_tokens(&tokens)?;
    // parse numstat rows
    let numstat = parse_numstat_tokens(rest)?;

    // merge raw and numstat
    let mut files = files.into_iter().collect::<HashMap<String, FileEntry>>();
    for (path, delta) in numstat {
        if let Some(mut file) = files.remove(&path) {
            file.delta = Some(delta);
            ret.push(file);
        }
    }
    Ok(ret)
}

const LOG_FORMAT: &str = "\
    id:%H%n\
    parents:%P%n\
    author:%an%n\
    mail:%ae%n\
    date:%at%n\
    summary:%s%n\
    body:{{{%n\
    %w(0,1,1)%b%n\
    %w(0)}}}%n";

const ID: &str = "id";
const PARENTS: &str = "parents";
const AUTHOR: &str = "author";
const MAIL: &str = "mail";
const DATE: &str = "date";
const SUMMARY: &str = "summary";
const BODY: &str = "body";

enum Region {
    Props,
    Body,
    Files,
}

/**
 * parse output generated by `git show {rev} --format={LOG_FORMAT} --numstat --raw -z`
 *
 * id:{id}\n
 * parents:{parents}\n
 * author:{author}\n
 * mail:{author mail}\n
 * date:{author-date}\n
 * summary:{summary}\n
 * body:{{{
 *  {body (indent by single blank, maybe multi line)}
 * }}}
 *
 * M<NUL>dir/foo.txt<NUL>A<NUL>dir/bar.txt<NUL>R100<NUL>dir/baz-new.txt<NUL>dir/baz-old.txt...
 */
fn parse_commit_detail_output(output: &str) -> Result<CommitDetail, GitError> {
    let mut region = Region::Props;
    let mut id = "";
    let mut parents = "";
    let mut author = "";
    let mut mail_address = "";
    let mut date: u64 = 0;
    let mut summary = "";
    let mut body = String::from("");
    let mut files: Vec<FileEntry> = Vec::new();
    for line in output.lines() {
        match region {
            Region::Props => {
                let kv: Vec<&str> = line.splitn(2, ':').collect();
                match kv.as_slice() {
                    [ID, value] => {
                        id = value;
                    }
                    [PARENTS, value] => {
                        parents = value;
                    }
                    [AUTHOR, value] => {
                        author = value;
                    }
                    [MAIL, value] => {
                        mail_address = value;
                    }
                    [DATE, value] => {
                        date = value.parse::<u64>().unwrap() * 1000;
                    }
                    [SUMMARY, value] => {
                        summary = value;
                    }
                    [BODY, _] => {
                        region = Region::Body;
                    }
                    _ => {
                        return Err(GitError::UnexpectedOutput {
                            command: String::from("show"),
                            text: line.to_string(),
                        });
                    }
                }
            }
            Region::Body => {
                if line == "}}}" {
                    body.pop(); // remove last \n
                    region = Region::Files;
                } else if line.len() == 0 {
                    return Err(GitError::UnexpectedOutput {
                        command: String::from("show"),
                        text: line.to_string(),
                    });
                } else {
                    body.push_str(&line[1..]);
                    body.push_str("\n");
                }
            }
            _ => {
                // Region::Files
                if line.len() == 0 || line.starts_with("\0") {
                    continue;
                }
                files = parse_raw_numstat_rows(line)?;
                break;
            }
        }
    }
    Ok(CommitDetail {
        commit: Commit::new(id, parents, author, mail_address, date, summary),
        body: body.to_string(),
        files,
    })
}

pub async fn get_commit_detail(repo_path: &Path, revspec: &str) -> Result<CommitDetail, GitError> {
    let format = format!("--format={}", LOG_FORMAT);
    let args = vec![
        revspec,
        "--raw",
        "--numstat",
        "--find-renames",
        "-z",
        &format,
    ];
    let output = exec(repo_path, "show", &args, &[]).await?;
    GitError::assert_process_output("show", &output)?;
    let stdout = std::str::from_utf8(&output.stdout).unwrap();
    parse_commit_detail_output(stdout)
}

#[cfg(test)]
mod tests {
    use super::*;

    fn text_delta(insertions: u32, deletions: u32) -> Option<FileDelta> {
        Some(FileDelta::Text {
            insertions,
            deletions,
        })
    }

    #[test]
    fn test_parse_raw_numstat() {
        const OUTPUT: &str = "\
        :100644 100644 55ee501 85acac2 M\0src/a.ts\0\
        :100644 100644 01023a8 95d7d82 A\0src/b.ts\0\
        :100644 100644 f40d040 9db3489 R90\0old.ts\0new.ts\0\
        5\t8\tsrc/a.ts\0\
        5\t0\tsrc/b.ts\0\
        2\t2\t\0old.ts\0new.ts\0\
        ";
        let expected = vec![
            FileEntry::new("src/a.ts", "M", None, text_delta(5, 8)),
            FileEntry::new("src/b.ts", "A", None, text_delta(5, 0)),
            FileEntry::new("new.ts", "R90", Some("old.ts"), text_delta(2, 2)),
        ];
        let actual = parse_raw_numstat_rows(OUTPUT).unwrap();
        assert_eq!(expected, actual);
    }
}
