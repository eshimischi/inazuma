use super::{exec, GitError};
use std::collections::HashMap;
use std::path::Path;
use types::*;

/**
 * parse output generated with `--numstat --raw -z`
 *
 *  Raw output format  https://git-scm.com/docs/git-diff#_raw_output_format
 *    in-place edit  :100644 100644 bcd1234 0123456 M<NUL>file0<NUL>
 *    copy-edit      :100644 100644 abcd123 1234567 C68<NUL>file1<NUL>file2<NUL>
 *    rename-edit    :100644 100644 abcd123 1234567 R86<NUL>file1<NUL>file3<NUL>
 *    create         :000000 100644 0000000 1234567 A<NUL>file4<NUL>
 *    delete         :100644 000000 1234567 0000000 D<NUL>file5<NUL>
 *    unmerged       :000000 000000 0000000 0000000 U<NUL>file6<NUL>
 *
 *  Numstat output format
 *    rename/copy    insertions<TAB>deletions<TAB><NUL>old path<NUL>new path<NUL>
 *    others         insertions<TAB>deletions<TAB>path<NUL>
 *
 *    insertions/deletions are inserted/deleted line count, or "-" when it is binary.
 */
pub fn parse_raw_numstat_rows(text: &str) -> Result<Vec<FileEntry>, GitError> {
    let mut files: HashMap<&str, FileEntry> = HashMap::new();
    let mut ret: Vec<FileEntry> = Vec::new();
    let mut tokens: Vec<&str> = text.split("\0").filter(|v| v.len() > 0).collect();
    tokens.reverse();
    while !tokens.is_empty() {
        let token = tokens.pop().unwrap();
        if token.starts_with(":") {
            // RAW OUTPUT
            let status_code = token.split(" ").collect::<Vec<_>>()[4];
            let status = status_code.chars().nth(0).unwrap();
            match status {
                'M' | 'A' | 'D' | 'T' | 'U' => {
                    let path: &str = tokens.pop().unwrap();
                    files.insert(path, FileEntry::new(&path, &status_code, None, None));
                }
                'R' | 'C' => {
                    let old_path = tokens.pop().unwrap();
                    let path = tokens.pop().unwrap();
                    files.insert(
                        path,
                        FileEntry::new(&path, &status_code, Some(&old_path), None),
                    );
                }
                _ => {
                    return Err(GitError::UnexpectedOutput {
                        command: String::from("numstat"),
                        text: format!("unknown status code: {}", token),
                    });
                }
            }
        } else {
            // NUMSTAT
            let values = token.split("\t").collect::<Vec<_>>();
            if values.len() != 3 {
                return Err(GitError::UnexpectedOutput {
                    command: String::from("numstat"),
                    text: format!("unknown numstat output: {}", token),
                });
            }
            let path = if values[2].len() > 0 {
                values[2]
            } else {
                tokens.pop();
                tokens.pop().unwrap()
            };
            if let Some(mut file) = files.remove(path) {
                match (values[0].parse::<u32>(), values[1].parse::<u32>()) {
                    (Ok(insertions), Ok(deletions)) => {
                        file.delta = Some(FileDelta::Text {
                            insertions,
                            deletions,
                        });
                    }
                    _ => {
                        file.delta = Some(FileDelta::Binary);
                    }
                }
                ret.push(file);
            }
        }
    }
    Ok(ret)
}

const LOG_FORMAT: &str = "\
    id:%H%n\
    parents:%P%n\
    author:%an%n\
    date:%at%n\
    summary:%s%n\
    body:{{{%n\
    %w(0,1,1)%b%n\
    %w(0)}}}%n";

const ID: &str = "id";
const PARENTS: &str = "parents";
const AUTHOR: &str = "author";
const DATE: &str = "date";
const SUMMARY: &str = "summary";
const BODY: &str = "body";

enum Region {
    Props,
    Body,
    Files,
}

/**
 * parse output generated by `git show {rev} --format={LOG_FORMAT} --numstat --raw -z`
 *
 * id:{id}\n
 * parents:{parents}\n
 * author:{author}\n
 * date:{author-date}\n
 * summary:{summary}\n
 * body:{{{
 *  {body (indent by single blank, maybe multi line)}
 * }}}
 *
 * M<NUL>dir/foo.txt<NUL>A<NUL>dir/bar.txt<NUL>R100<NUL>dir/baz-new.txt<NUL>dir/baz-old.txt...
 */
fn parse_commit_detail_output(output: &str) -> Result<CommitDetail, GitError> {
    let mut region = Region::Props;
    let mut id = "";
    let mut parents = "";
    let mut author = "";
    let mut date: u64 = 0;
    let mut summary = "";
    let mut body = String::from("");
    let mut files: Vec<FileEntry> = Vec::new();
    for line in output.lines() {
        match region {
            Region::Props => {
                let kv: Vec<&str> = line.splitn(2, ':').collect();
                match kv.as_slice() {
                    [ID, value] => {
                        id = value;
                    }
                    [PARENTS, value] => {
                        parents = value;
                    }
                    [AUTHOR, value] => {
                        author = value;
                    }
                    [DATE, value] => {
                        date = value.parse::<u64>().unwrap() * 1000;
                    }
                    [SUMMARY, value] => {
                        summary = value;
                    }
                    [BODY, _] => {
                        region = Region::Body;
                    }
                    _ => {
                        return Err(GitError::UnexpectedOutput {
                            command: String::from("show"),
                            text: line.to_string(),
                        });
                    }
                }
            }
            Region::Body => {
                if line == "}}}" {
                    body.pop(); // remove last \n
                    region = Region::Files;
                } else if line.len() == 0 {
                    return Err(GitError::UnexpectedOutput {
                        command: String::from("show"),
                        text: line.to_string(),
                    });
                } else {
                    body.push_str(&line[1..]);
                    body.push_str("\n");
                }
            }
            _ => {
                // Region::Files
                if line.len() == 0 || line.starts_with("\0") {
                    continue;
                }
                files = parse_raw_numstat_rows(line)?;
                break;
            }
        }
    }
    Ok(CommitDetail {
        commit: Commit::new(id, parents, author, date, summary),
        body: body.to_string(),
        files,
    })
}

pub async fn get_commit_detail(repo_path: &Path, revspec: &str) -> Result<CommitDetail, GitError> {
    let format = format!("--format={}", LOG_FORMAT);
    let args = vec![
        revspec,
        "--raw",
        "--numstat",
        "--find-renames",
        "-z",
        &format,
    ];
    let output = exec(repo_path, "show", &args, &[]).await?;
    GitError::assert_process_output("show", &output)?;
    let stdout = std::str::from_utf8(&output.stdout).unwrap();
    parse_commit_detail_output(stdout)
}
