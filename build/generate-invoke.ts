import fs from "node:fs";
import path from "node:path";
import cp from "node:child_process";
import Handlebars from "handlebars";
import type { TsFunc } from "../src-tauri/generate/bindings/TsFunc";
import type { TsArg } from "../src-tauri/generate/bindings/TsArg";
import type { TsType } from "../src-tauri/generate/bindings/TsType";

const OUTPUT_PATH = "src/react/generated/tauri-invoke.d.ts";

type TranslatedFunc = {
  name: string;
  payloadType: string;
  retType: string;
};

const createParentDirectoryIfNeeded = (filePath: string) => {
  const parent = path.dirname(filePath);
  if (!fs.existsSync(parent)) {
    fs.mkdirSync(parent, { recursive: true });
  }
};

const unreachable = (_: never): never => {
  throw new Error("This should be unreachable");
};

const toCamelCase = (value: string): string =>
  value.replace(/_([a-z])/g, (_, g: string) => g.toUpperCase());

const typeToString = (ty: TsType, imports: Set<string>): string => {
  switch (ty.kind) {
    case "String":
    case "Number":
    case "Boolean":
    case "Void":
      return ty.kind.toLowerCase();
    case "Ignored":
    case "Invalid":
      return `${ty.kind}<"${ty.content}">`;
    case "Array":
      return `Array<${typeToString(ty.content, imports)}>`;
    case "Optional": {
      const inner = typeToString(ty.content, imports);
      return ty.content.kind === "Optional" ? inner : `(${inner}) | undefined`;
    }
    case "Record": {
      const key = typeToString(ty.content.key, imports);
      const value = typeToString(ty.content.value, imports);
      return `Record<${key}, ${value}>`;
    }
    case "Tuple":
      return `[${ty.content.map((t) => typeToString(t, imports)).join(", ")}]`;
    case "UserDefined":
      imports.add(ty.content);
      return ty.content;
    default:
      return unreachable(ty);
  }
};

const argsToString = (args: TsArg[], imports: Set<string>): string => {
  const content = args
    .filter((a) => a.ty.kind !== "Ignored")
    .map((a) => {
      const name = toCamelCase(a.name) + (a.ty.kind === "Optional" ? "?" : "");
      return `${name}: ${typeToString(a.ty, imports)}`;
    });
  return content.length > 0 ? `{ ${content.join(", ")} }` : "";
};

const translateTsFunc = (func: TsFunc, imports: Set<string>): TranslatedFunc => {
  const { name, args, ret } = func;
  return {
    name,
    payloadType: argsToString(args, imports),
    retType: ret.kind === "Ignored" ? "void" : typeToString(ret, imports)
  };
};

const generateInvokeType = () => {
  const ret = cp.spawnSync("cargo", "run -- --src ../app/src/commands.rs".split(" "), {
    cwd: "src-tauri/generate",
    stdio: ["ignore", "pipe", "inherit"]
  });
  if (ret.error) {
    throw ret.error;
  }
  const json = ret.stdout.toString("utf-8");
  const funcDefs = (JSON.parse(json) as TsFunc[]).sort((a, b) => a.name.localeCompare(b.name));

  const imports = new Set<string>();
  const data: TranslatedFunc[] = funcDefs.map((f) => translateTsFunc(f, imports));
  const template = Handlebars.compile(`/* eslint-disable */

/*
 * Generated by build/generate-dts.ts
 *
 * Don't modify this file directly
 */

{{#each imports}}
import { {{{.}}} } from "@backend/{{{.}}}";
{{/each}}

export type TauriInvokeType = {
{{#each data}}
  "{{{name}}}": {
    args: [{{{payloadType}}}],
    ret: {{{retType}}}
  };
{{/each}}
};

export type TauriInvoke = <K extends keyof TauriInvokeType>(
  command: K,
  ...payload: TauriInvokeType[K]["args"]
) => Promise<TauriInvokeType[K]["ret"]>;
`);
  return template({ data, imports: [...imports].sort() });
};

const main = () => {
  createParentDirectoryIfNeeded(OUTPUT_PATH);
  fs.writeFileSync(OUTPUT_PATH, generateInvokeType());
};

main();
