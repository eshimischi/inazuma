import fs from "fs";
import path from "path";
import cp from "child_process";
import Handlebars from "handlebars";
import { TsFunc } from "../src-tauri/generate/bindings/TsFunc";
import { TsArg } from "../src-tauri/generate/bindings/TsArg";
import { TsType } from "../src-tauri/generate/bindings/TsType";

const OUTPUT_PATH = "src/react/generated/tauri-invoke.d.ts";

type TranslatedFunc = {
  name: string;
  payloadType: string;
  retType: string;
};

const createParentDirectoryIfNeeded = (filePath: string) => {
  const parent = path.dirname(filePath);
  if (!fs.existsSync(parent)) {
    fs.mkdirSync(parent, { recursive: true });
  }
};

const unreachable = (_: never): never => {
  throw new Error("This should be unreachable");
};

const toCamelCase = (value: string): string =>
  value.replace(/_([a-z])/g, (_, g: string) => g.toUpperCase());

const translateType = (ty: TsType, userDefinedTypes: Set<string>): string => {
  switch (ty.kind) {
    case "String":
    case "Number":
    case "Boolean":
    case "Void":
      return ty.kind.toLowerCase();
    case "Ignored":
    case "Invalid":
      return `${ty.kind}<"${ty.content}">`;
    case "Array":
      return `Array<${translateType(ty.content, userDefinedTypes)}>`;
    case "Optional": {
      const inner = translateType(ty.content, userDefinedTypes);
      return ty.content.kind === "Optional" ? inner : `(${inner}) | undefined`;
    }
    case "Record":
      return `Record<${translateType(ty.content.key, userDefinedTypes)}, ${translateType(
        ty.content.value,
        userDefinedTypes
      )}>`;
    case "Tuple":
      return `[${ty.content.map((t) => translateType(t, userDefinedTypes)).join(", ")}]`;
    case "UserDefined":
      userDefinedTypes.add(ty.content);
      return ty.content;
    default:
      return unreachable(ty);
  }
};

const translateArgs = (args: TsArg[], userDefinedTypes: Set<string>) => {
  const content = args
    .filter((a) => a.ty.kind !== "Ignored")
    .map((a) => {
      const name = toCamelCase(a.name) + (a.ty.kind === "Optional" ? "?" : "");
      return `${name}: ${translateType(a.ty, userDefinedTypes)}`;
    });
  return content.length > 0 ? `{ ${content.join(", ")} }` : "";
};

const translateFunc = (func: TsFunc, userDefinedTypes: Set<string>): TranslatedFunc => {
  const { name, args, ret } = func;
  return {
    name,
    payloadType: translateArgs(args, userDefinedTypes),
    retType: ret.kind === "Ignored" ? "void" : translateType(ret, userDefinedTypes)
  };
};

const generateInvokeType = () => {
  const ret = cp.spawnSync("cargo", "run -- --src ../app/src/commands.rs".split(" "), {
    cwd: "src-tauri/generate",
    stdio: ["ignore", "pipe", "inherit"]
  });
  if (ret.error) {
    throw ret.error;
  }
  const json = ret.stdout.toString("utf-8");
  const funcDefs = (JSON.parse(json) as TsFunc[]).sort((a, b) => a.name.localeCompare(b.name));

  const userDefinedTypes = new Set<string>();
  const data: TranslatedFunc[] = funcDefs.map((f) => translateFunc(f, userDefinedTypes));
  const template = Handlebars.compile(`/* eslint-disable */

/*
 * Generated by build/generate-dts.ts
 *
 * Don't modify this file directly
 */

{{#each userDefinedTypes}}
import { {{{.}}} } from "@backend/{{{.}}}";
{{/each}}

// prettier-ignore
export type TauriInvokeType = {
{{#each data}}
  "{{{name}}}": {
    args: [{{{payloadType}}}],
    ret: {{{retType}}}
  };
{{/each}}
};

export type TauriInvoke = <K extends keyof TauriInvokeType>(
  command: K,
  ...payload: TauriInvokeType[K]["args"]
) => Promise<TauriInvokeType[K]["ret"]>;
`);
  return template({ data, userDefinedTypes: [...userDefinedTypes].sort() });
};

const main = () => {
  createParentDirectoryIfNeeded(OUTPUT_PATH);
  fs.writeFileSync(OUTPUT_PATH, generateInvokeType());
};

main();
