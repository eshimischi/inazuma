import fs from "fs";
import path from "path";
import Handlebars from "handlebars";
import { compileFromFile } from "json-schema-to-typescript";
import { TsFunc, TsArg, TsType } from "./tsfunc";
import prettier from "prettier";

const TAURI_TYPE_SCHEMA = "src/react/generated/tauri-schema.json";
const TAURI_INVOKE_DEFS = "src/react/generated/tauri-invoke.json";
const OUTPUT_PATH = "src/react/generated/tauri-types.d.ts";

const BANNER = `/* eslint-disable */

/*
 * Generated by build/generate-dts.ts
 *
 * Don't modify this file directly
 */
`;

type TranslatedFunc = {
  name: string;
  payloadType: string;
  retType: string;
};

const createParentDirectoryIfNeeded = (filePath: string) => {
  const parent = path.dirname(filePath);
  if (!fs.existsSync(parent)) {
    fs.mkdirSync(parent, { recursive: true });
  }
};

/**
 * Generate type definitions from JSON schema
 */
const generateTypesFromSchema = (filePath: string): Promise<string> => {
  createParentDirectoryIfNeeded(filePath);
  return compileFromFile(filePath, {
    bannerComment: ""
  });
};

const unreachable = (_: never): never => {
  throw new Error("This should be unreachable");
};

const toCamelCase = (value: string): string =>
  value.replace(/_([a-z])/g, (_, g: string) => g.toUpperCase());

const isValidType = (ty: TsType, allowIgnored: boolean): boolean => {
  switch (ty.kind) {
    case "String":
    case "Number":
    case "Boolean":
    case "Void":
    case "UserDefined":
      return true;
    case "Ignored":
      return allowIgnored;
    case "Invalid":
      return false;
    case "Array":
    case "Optional":
      return isValidType(ty.content, false);
    case "Record":
      return isValidType(ty.content.key, false) && isValidType(ty.content.value, false);
    case "Tuple":
      return ty.content.every((t) => isValidType(t, false));
    default:
      return unreachable(ty);
  }
};

const translateType = (ty: TsType): string => {
  switch (ty.kind) {
    case "String":
    case "Number":
    case "Boolean":
    case "Void":
      return ty.kind.toLowerCase();
    case "Ignored":
    case "Invalid":
      return `${ty.kind}<"${ty.content}">`;
    case "Array":
      return `Array<${translateType(ty.content)}>`;
    case "Optional": {
      const inner = translateType(ty.content);
      return ty.content.kind === "Optional" ? inner : `(${inner}) | undefined`;
    }
    case "Record":
      return `Record<${translateType(ty.content.key)}, ${translateType(ty.content.value)}>`;
    case "Tuple":
      return `[${ty.content.map(translateType).join(", ")}]`;
    case "UserDefined":
      return ty.content;
    default:
      return unreachable(ty);
  }
};

const translateArgs = (args: TsArg[]) => {
  const content = args
    .filter((a) => a.ty.kind !== "Ignored")
    .map((a) => {
      const name = toCamelCase(a.name) + (a.ty.kind === "Optional" ? "?" : "");
      return `${name}: ${translateType(a.ty)}`;
    });
  return content.length > 0 ? `{ ${content.join(", ")} }` : "";
};

const translateFunc = (func: TsFunc): TranslatedFunc => {
  const { name, args, ret } = func;
  return {
    name,
    payloadType: translateArgs(args),
    retType: ret.kind === "Ignored" ? "void" : translateType(ret)
  };
};

const generateInvokeType = async (filePath: string) => {
  createParentDirectoryIfNeeded(filePath);
  const input = await fs.promises.readFile(filePath, { encoding: "utf-8" });
  const invokeDef = JSON.parse(input) as TsFunc[];
  let hasError: boolean = false;
  invokeDef.forEach((func) => {
    func.args.forEach((a) => {
      if (!isValidType(a.ty, true)) {
        console.error(`${func.name} has invalid argument: ${a.name}`);
        console.error(`  ${translateType(a.ty)}`);
        hasError = true;
      }
    });
    if (!isValidType(func.ret, false)) {
      console.error(`${func.name} has invalid return type`);
      console.error(`  ${translateType(func.ret)}`);
      hasError = true;
    }
  });
  if (hasError) {
    throw new Error("Invoke definition contains invalid type");
  }
  const data: TranslatedFunc[] = invokeDef.map(translateFunc);
  const template = Handlebars.compile(`
export type TauriInvokeType = {
{{#each data}}
  "{{{name}}}": { args: [{{{payloadType}}}], ret: {{{retType}}} };
{{/each}}
};

export type TauriInvoke = <K extends keyof TauriInvokeType>(
  command: K,
  ...payload: TauriInvokeType[K]["args"]
) => Promise<TauriInvokeType[K]["ret"]>;
`);
  return template({ data });
};

const generate = async () => {
  const types = await generateTypesFromSchema(TAURI_TYPE_SCHEMA);
  const invoke = await generateInvokeType(TAURI_INVOKE_DEFS);
  const code = [BANNER, types, invoke].join("\n");
  const formatted = prettier.format(code, { parser: "typescript" });
  await fs.promises.writeFile(OUTPUT_PATH, formatted);
};

generate()
  .then(() => console.log("done."))
  .catch((e) => console.error("Failed to generate: ", e));
